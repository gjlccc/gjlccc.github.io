---
title: 2024河南省赛G题题解
date: 2024-05-15 22:29:58
tags: 2024河南省赛
---

先占个坑，等我博客重建完.

来填坑了

感觉思路对是对的，毕竟题目过了，但是还是不够简单，特判太多了，跟着check出来的一点点改的，才慢慢找齐的

题目只有pdf，地址请点：[2024河南省赛]([Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158))。（别问我为什么链接时露出来的，我不会修）。

我们只要把下文介绍的的两种构造方案，和特判组合起来就能通过啦。

幸亏这题的 $check$ 十分好写，不然 $vp$ 的时候应该是出不来的。

方案讲解是跟着作者的一步一步构造出来正确答案的过程来的，有些中间部分时有问题的，请先耐心看完，如果还有问题再提出。

求一个好的画图软件www，本文的图都是excel画的，别喷我这一点。

## 第一种构造方案

### 使用条件：

在满足 $m \geq \lfloor \frac{n^2}{2} \rfloor +2$​ 时。

最想也最不会出错的一种，可惜范围有限

### 文字描述：

首先进行隔位填 $1$ 使用 $\frac{n^2}{2}+2$ 个雷，来给出一个框架，使得使所有 $0$ 的位置周围的雷的数量都大于 $2$ 那么之后的我们只需要找顺序遍历把剩余 $m - \lfloor \frac{n^2}{2} \rfloor +2$ 个雷填到空的格子里就可以 。

在 $n$ 为奇数的隔位填 $1$ 刚好满足使所有 $0$ 的位置周围的雷的数量都大于 $2$ 。

在 $n$ 偶数时还需填上 $a[1][n]$ 和 $a[n][1]$ 两个格子才能满足。否则这两个格子周围雷的数量刚好是2。

### 图例：

![5X5示例](/pic/方案一示例5X5.png)

![6X6示例](/pic/方案一示例6X6.png)

## 第二种构造方案

### 使用条件：

这是一般性的构造方案，除了第一种构造方案和特判就都用这种的。

感觉这种方案要拿出来的特判太多了，所以我认为这不是一种优秀的方案

### 基本策略

文字+图片描述（感觉分开太难描述了）：

我们将一个十字的放置视作最小单元

![最小的单元](/pic/最小单元.png)

确立基本原则，每次放置要将整个最小单元放置，最右端和最下端超出边界直接删去超出边界那个即可。

我们用其中心点来定位，第一个中心点在 $(2,2)$ ，下一个在 $(2,5)$ ，就这样向后放置直到这一行放不下了，

到下一行从 $(5,2)$ 开始往后放置，以此类推即可。

最小单元放完了，或者未填的 $m$ 个数不足以放置下一个最小单元时

从头开始填充 $m$ 个为 $0$​ 的位置。

$5*5$ 的放置示例：

 ![5*5的放置示例](/pic/方案二5X5示例.png)

$7*7$ 的放置示例:

![7*7的放置示例](/pic/方案二7X7示例.png)

当我们计算个数时只要保证上届能衔接到第一种方案就行，小的部分余下的需要特判的数量不会很多（至少不是会导致写1000行的代码）。不知道为什么多截了一行，当成 $7*7$ 就好了。

凭借感觉我们就能感觉到 $7*7$ 的时候时上最劣的情况

![7*7上限](/pic/方案二可放置数量分析.png)

黄色的为最小单位组成的框架，蓝色的地方是能填充的地方，一共29个，$29 > 26$ 。

个数足够到达第一种方案

### 针对于错误的改进

#### 错误一：

聪明的你一定想到了，以上方法构造出来的东西是有问题的

假设 $n=10,m=20$ 时根据以上，我们会构造出来这样一张图。

![错误示例一](/pic/方案二示例错误1.png)

在红色格子周围一共 $2$ 个雷。

当时做到这，一下子就蒙了一下，写了真的很久，坚信之前的底子没错只要小修改一下就好，还好改出来了。

#### 修改措施一：

我们从第二行（最小单元的）开始，将最小单元再加上一个，变成六个一组就可以啦，只是特判的东西要再多一点了。

![修改示例二](/pic/方案二示例修改1.png)

绿色的为第二行开始的构造的最小单元。这样红色格子旁边就有3个雷了，问题解决!

#### 错误二：

这是由错误一引发的错误

当 $n=7,m=22$ 时，我们会构造出来这样一张图

![错误示例2](/pic/错误示例2.png)

黄色的时我们填充的单元格，红色的为周围雷的个数为 $2$ 的格子

#### 修改措施二：

直接判断是不是本行最后一个能放置的，如果是，就把右上角那个在当前这个最小单元里的踢出去就好了

![修改示例2](/pic/修改示例2.png)

解决！

#### 错误三：

当最小单元组成的边框所留出来的空格足够，但是遍历的时候将不是雷的直接设置雷的时候会有错误

例如 $n=7 ,m=21$ 时

![错误示例3](/pic/错误示例3.png)

黄色绿色都是填上的格子。会发现明显错误。

#### 修改措施三：

记录最后一次的最小单元放置的中心点位置，

假设为 $(i,j)$ ,那么当遇到点 $(i-2,j+2)$ 时直接换到下一行。

![修改示例3](/pic/修改示例3.png)

黄色和橙色都是放置的雷，

橙色表示最后一个最小单元的中心点，红色为 $(i-2,j+2)$ 。

### 方案二完结

## 第三种构造方案

 ### 使用条件：

所有方案一，方案二会错误的，解决不掉的，都用方案三，因为，方案三就是填洞洞来的。

### 构造方法

无，一个补洞洞的还想要什么方法，一个一个对着造就好了

以下方法，空格上的数字表示，若 $m\geq $ 当前空格上的数字，则填上这格

#### $1\leq m\leq 4$时：

![1234](/pic/1234.png)

#### $5\leq m\leq 7$​时：

![567](/pic/567.png)

#### $8\leq m\leq 9$​时：

![89](/pic/89.png)

#### $n=5 ,m=13$时：

![n=5,13](/pic/n=5,13.png)

#### $(n=6 \or n=7) \and (m=14\or m=15) $时：

![n!=67,1415](/pic/n!=67,1415.png)

## 代码

差点给忘了还要把代码给上，check也在里面了。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e3 + 5;
int a[N][N];
int n, m, rm;
void ans1()
{
    for (ll i = 1; i <= n; i++)
    {
        for (ll j = 1; j <= n; j++)
        {
            if ((i + j) % 2 == 0)
            {
                a[i][j] = 1;
                m--;
            }
        }
    }
    if (n % 2 == 0)
        a[1][n] = 1, a[n][1] = 1, m -= 2;
    for (ll i = 1; i <= n; i++)
    {
        for (ll j = 1; j <= n; j++)
        {
            if (m == 0)
                break;
            m = m - (1 - a[i][j]);
            a[i][j] = 1;
        }
        if (m == 0)
            break;
    }
}
void ans2()
{
    ll lsx = 0, lsy = 0;
    ;
    for (ll i = 2; i <= n; i += 3)
    {
        bool f = false;
        for (ll j = 2; j <= n; j += 3)
        {
            ll res = 3;
            if (j + 1 <= n)
                res++;
            if (i + 1 <= n)
                res++;
            if (i > 2 && j + 1 <= n && j != ((n + 1) / 3) * 3 - 1)
                res++;
            if (m >= res)
            {
                lsx = i;
                lsy = j;
                m -= res;
                a[i][j] = 1;
                a[i - 1][j] = 1;
                a[i + 1][j] = 1;
                a[i][j - 1] = 1;
                a[i][j + 1] = 1;
                if (i > 2 && j + 1 <= n && j != ((n + 1) / 3) * 3 - 1)
                    a[i - 2][j + 1] = 1;
            }
            else
            {
                f = true;
                break;
            }
        }
        if (f)
            break;
    }
    // ll bj=((n+1)/3)*3-1;
    // cout<<bj<<"\n";
    for (ll i = 1; i <= ((n + 1) / 3) * 3 - 1; i++)
    {
        for (ll j = 1; j <= ((n + 1) / 3) * 3 - 1; j++)
        {
            if (m == 0)
                break;
            if (i == lsx - 2 && j == lsy + 2)
                continue;
            m = m - (1 - a[i][j]);
            a[i][j] = 1;
        }
        if (m == 0)
            break;
    }
}
void init()
{
    for (ll i = 1; i <= n; i++)
    {
        for (ll j = 1; j <= n; j++)
        {
            a[i][j] = 0;
        }
    }
}
void ppp()
{
    cout << "Yes\n";
    for (ll i = 1; i <= n; i++)
    {
        for (ll j = 1; j <= n; j++)
        {
            cout << a[i][j];
        }
        cout << "\n";
    }
}
void solve()
{
    rm = m;
    cin >> n >> m;
    init();
    if ((n == 6 || n == 7) && (m == 14 || m == 15))
    {
        a[1][2] = 1;
        a[6][5] = 1;
        for (ll i = 2; i <= 5; i++)
        {
            for (ll j = i - 1; j <= i + 1; j++)
            {
                a[i][j] = 1;
            }
        }
        if (m == 15)
            a[1][1] = 1;
    }
    else if (m >= n * n / 2 + 2)
        ans1();
    else if (m <= 14)
    {
        if (m <= 4)
        {
            a[1][1] = 1;
            if (m >= 2)
                a[1][4] = 1;
            if (m >= 3)
                a[4][1] = 1;
            if (m >= 4)
                a[4][4] = 1;
        }
        else if (m <= 7)
        {
            a[1][2] = 1;
            a[2][1] = 1;
            a[2][2] = 1;
            a[2][3] = 1;
            a[3][2] = 1;
            if (m >= 6)
                a[1][1] = 1;
            if (m == 7)
                a[5][5] = 1;
        }
        else if (m <= 9)
        {
            a[1][2] = 1;
            a[2][1] = 1;
            a[2][2] = 1;
            a[2][3] = 1;
            a[3][2] = 1;
            a[3][3] = 1;
            a[3][4] = 1;
            a[4][3] = 1;
            if (m == 9)
                a[1][1] = 1;
        }
        else
        {
            if (n == 5)
            {
                if (m == 13)
                {
                    for (ll i = 1; i <= n; i++)
                    {
                        for (ll j = 1; j <= n; j++)
                        {
                            if (i - j == 0)
                                a[i][j] = 1;
                            if (i - j == -1)
                                a[i][j] = 1;
                            if (i - j == 1)
                                a[i][j] = 1;
                        }
                    }
                }
                else
                    ans2();
            }
            else
            {
                if (m <= 13)
                    ans2();
                else
                {
                    a[1][2] = 1;
                    a[6][5] = 1;
                    for (ll i = 2; i <= 5; i++)
                    {
                        for (ll j = i - 1; j <= i + 1; j++)
                        {
                            a[i][j] = 1;
                        }
                    }
                }
            }
        }
    }
    else
        ans2();
    ppp();
}
void checker()
{
    ll res = 0;
    for (ll i = 1; i <= n; i++)
    {
        for (ll j = 1; j <= n; j++)
        {
            res += a[i][j];
            if (a[i][j] == 0)
            {
                ll pd = 0;
                for (ll x = max(i - 1, 0ll); x <= min(i + 1, (ll)n); x++)
                {
                    for (ll y = max(j - 1, 0ll); y <= min(j + 1, (ll)n); y++)
                    {
                        pd += a[x][y];
                    }
                }
                if (pd == 2)
                {
                    cout << i << " " << j << " " << n << " " << rm << "stop\n";
                    exit(0);
                }
            }
        }
    }
    if (res != rm)
    {
        cout << n << " " << rm << "stop\n";
        exit(0);
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    ll t = 1;
    cin >> t;
    while (t--)
        solve();
    // for(n=5;n<=20;n++){
    //     for(ll j=1;j<=n*n;j++){
    //     cout<<n<<" "<<j<<"\n";
    //     m=j;
    //     solve();
    //     checker();
    //     }
    // }
    return 0;
}
```



## 完结

完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

第一次vp中做出这么好玩有趣的构造题。

看过题解了，根本想不到www。确实简单很多。

有问题可以邮箱联系(2945389643@qq.com) 先，乐意解答。

不好意思加的就等我把gitalk搞定吧。

感谢阅读！
